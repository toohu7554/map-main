{"version":3,"file":"L.Control.Locate.min.js","sources":["../src/L.Control.Locate.js"],"sourcesContent":["/*!\nCopyright (c) 2016 Dominik Moritz\n\nThis file is part of the leaflet locate control. It is licensed under the MIT license.\nYou can find the project at: https://github.com/domoritz/leaflet-locatecontrol\n*/\n\nimport { Control, Marker, DomUtil, setOptions, divIcon, extend, LayerGroup, circle, DomEvent, Util as LeafletUtil } from \"leaflet\";\nconst addClasses = (el, names) => {\n  names.split(\" \").forEach((className) => {\n    el.classList.add(className);\n  });\n};\n\nconst removeClasses = (el, names) => {\n  names.split(\" \").forEach((className) => {\n    el.classList.remove(className);\n  });\n};\n\n/**\n * Compatible with Circle but a true marker instead of a path\n */\nconst LocationMarker = Marker.extend({\n  initialize(latlng, options) {\n    setOptions(this, options);\n    this._latlng = latlng;\n    this.createIcon();\n  },\n\n  /**\n   * Create a styled circle location marker\n   */\n  createIcon() {\n    const opt = this.options;\n\n    const style = [\n      [\"stroke\", opt.color],\n      [\"stroke-width\", opt.weight],\n      [\"fill\", opt.fillColor],\n      [\"fill-opacity\", opt.fillOpacity],\n      [\"opacity\", opt.opacity]\n    ]\n      .filter(([k,v]) => v !== undefined)\n      .map(([k,v]) => `${k}=\"${v}\"`)\n      .join(\" \");\n\n    const icon = this._getIconSVG(opt, style);\n\n    this._locationIcon = divIcon({\n      className: icon.className,\n      html: icon.svg,\n      iconSize: [icon.w, icon.h]\n    });\n\n    this.setIcon(this._locationIcon);\n  },\n\n  /**\n   * Return the raw svg for the shape\n   *\n   * Split so can be easily overridden\n   */\n  _getIconSVG(options, style) {\n    const r = options.radius;\n    const w = options.weight;\n    const s = r + w;\n    const s2 = s * 2;\n    const svg =\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${s2}\" height=\"${s2}\" version=\"1.1\" viewBox=\"-${s} -${s} ${s2} ${s2}\">` +\n      `<circle r=\"${r}\" ${style} /></svg>`;\n    return {\n      className: \"leaflet-control-locate-location\",\n      svg,\n      w: s2,\n      h: s2\n    };\n  },\n\n  setStyle(style) {\n    setOptions(this, style);\n    this.createIcon();\n  }\n});\n\nconst CompassMarker = LocationMarker.extend({\n  initialize(latlng, heading, options) {\n    setOptions(this, options);\n    this._latlng = latlng;\n    this._heading = heading;\n    this.createIcon();\n  },\n\n  setHeading(heading) {\n    this._heading = heading;\n  },\n\n  /**\n   * Create a styled arrow compass marker\n   */\n  _getIconSVG(options, style) {\n    const r = options.radius;\n    const s = r + options.weight + options.depth;\n    const s2 = s * 2;\n\n    const path = this._arrowPoints(r, options.width, options.depth, this._heading);\n\n    const svg =\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${s2}\" height=\"${s2}\" version=\"1.1\" viewBox=\"-${s} -${s} ${s2} ${s2}\">` +\n      `<path d=\"${path}\" ${style} /></svg>`;\n    return {\n      className: \"leaflet-control-locate-heading\",\n      svg,\n      w: s2,\n      h: s2\n    };\n  },\n\n  _arrowPoints(radius, width, depth, heading) {\n    const φ = ((heading - 90) * Math.PI) / 180;\n    const ux = Math.cos(φ);\n    const uy = Math.sin(φ);\n    const vx = -Math.sin(φ);\n    const vy = Math.cos(φ);\n    const h = width / 2;\n\n    // Base center on circle\n    const Cx = radius * ux;\n    const Cy = radius * uy;\n\n    // Base corners\n    const B1x = Cx + h * vx;\n    const B1y = Cy + h * vy;\n    const B2x = Cx - h * vx;\n    const B2y = Cy - h * vy;\n\n    // Tip outward\n    const Tx = Cx + depth * ux;\n    const Ty = Cy + depth * uy;\n\n    return `M ${B1x},${B1y} L ${B2x},${B2y} L ${Tx},${Ty} Z`;\n  }\n});\n\nconst LocateControl = Control.extend({\n  options: {\n    /** Position of the control */\n    position: \"topleft\",\n    /** The layer that the user's location should be drawn on. By default creates a new layer. */\n    layer: undefined,\n    /**\n     * Automatically sets the map view (zoom and pan) to the user's location as it updates.\n     * While the map is following the user's location, the control is in the `following` state,\n     * which changes the style of the control and the circle marker.\n     *\n     * Possible values:\n     *  - false: never updates the map view when location changes.\n     *  - 'once': set the view when the location is first determined\n     *  - 'always': always updates the map view when location changes.\n     *              The map view follows the user's location.\n     *  - 'untilPan': like 'always', except stops updating the\n     *                view if the user has manually panned the map.\n     *                The map view follows the user's location until she pans.\n     *  - 'untilPanOrZoom': (default) like 'always', except stops updating the\n     *                view if the user has manually panned the map.\n     *                The map view follows the user's location until she pans.\n     */\n    setView: \"untilPanOrZoom\",\n    /** Keep the current map zoom level when setting the view and only pan. */\n    keepCurrentZoomLevel: false,\n    /** After activating the plugin by clicking on the icon, zoom to the selected zoom level, even when keepCurrentZoomLevel is true. Set to 'false' to disable this feature. */\n    initialZoomLevel: false,\n    /**\n     * This callback can be used to override the viewport tracking\n     * This function should return a LatLngBounds object.\n     *\n     * For example to extend the viewport to ensure that a particular LatLng is visible:\n     *\n     * getLocationBounds: function(locationEvent) {\n     *    return locationEvent.bounds.extend([-33.873085, 151.219273]);\n     * },\n     */\n    getLocationBounds(locationEvent) {\n      return locationEvent.bounds;\n    },\n    /** Smooth pan and zoom to the location of the marker. Only works in Leaflet 1.0+. */\n    flyTo: false,\n    /**\n     * The user location can be inside and outside the current view when the user clicks on the\n     * control that is already active. Both cases can be configures separately.\n     * Possible values are:\n     *  - 'setView': zoom and pan to the current location\n     *  - 'stop': stop locating and remove the location marker\n     */\n    clickBehavior: {\n      /** What should happen if the user clicks on the control while the location is within the current view. */\n      inView: \"stop\",\n      /** What should happen if the user clicks on the control while the location is outside the current view. */\n      outOfView: \"setView\",\n      /**\n       * What should happen if the user clicks on the control while the location is within the current view\n       * and we could be following but are not. Defaults to a special value which inherits from 'inView';\n       */\n      inViewNotFollowing: \"inView\"\n    },\n    /**\n     * If set, save the map bounds just before centering to the user's\n     * location. When control is disabled, set the view back to the\n     * bounds that were saved.\n     */\n    returnToPrevBounds: false,\n    /**\n     * Keep a cache of the location after the user deactivates the control. If set to false, the user has to wait\n     * until the locate API returns a new location before they see where they are again.\n     */\n    cacheLocation: true,\n    /** If set, a circle that shows the location accuracy is drawn. */\n    drawCircle: true,\n    /** If set, the marker at the users' location is drawn. */\n    drawMarker: true,\n    /** If set and supported then show the compass heading */\n    showCompass: true,\n    /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */\n    markerClass: LocationMarker,\n    /** The class us be used to create the compass bearing arrow */\n    compassClass: CompassMarker,\n    /** Accuracy circle style properties. NOTE these styles should match the css animations styles */\n    circleStyle: {\n      className: \"leaflet-control-locate-circle\",\n      color: \"#136AEC\",\n      fillColor: \"#136AEC\",\n      fillOpacity: 0.15,\n      weight: 0\n    },\n    /** Inner marker style properties. Only works if your marker class supports `setStyle`. */\n    markerStyle: {\n      className: \"leaflet-control-locate-marker\",\n      color: \"#fff\",\n      fillColor: \"#2A93EE\",\n      fillOpacity: 1,\n      weight: 3,\n      opacity: 1,\n      radius: 9\n    },\n    /** Compass */\n    compassStyle: {\n      fillColor: \"#2A93EE\",\n      fillOpacity: 1,\n      weight: 0,\n      color: \"#fff\",\n      opacity: 1,\n      radius: 9, // How far is the arrow from the center of the marker\n      width: 9, // Width of the arrow\n      depth: 6 // Length of the arrow\n    },\n    /**\n     * Changes to accuracy circle and inner marker while following.\n     * It is only necessary to provide the properties that should change.\n     */\n    followCircleStyle: {},\n    followMarkerStyle: {\n      // color: '#FFA500',\n      // fillColor: '#FFB000'\n    },\n    followCompassStyle: {},\n    /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */\n    icon: \"leaflet-control-locate-location-arrow\",\n    iconLoading: \"leaflet-control-locate-spinner\",\n    /** The element to be created for icons. For example span or i */\n    iconElementTag: \"span\",\n    /** The element to be created for the text. For example small or span */\n    textElementTag: \"small\",\n    /** Padding around the accuracy circle. */\n    circlePadding: [0, 0],\n    /** Use metric units. */\n    metric: true,\n    /**\n     * This callback can be used in case you would like to override button creation behavior.\n     * This is useful for DOM manipulation frameworks such as angular etc.\n     * This function should return an object with HtmlElement for the button (link property) and the icon (icon property).\n     */\n    createButtonCallback(container, options) {\n      const link = DomUtil.create(\"a\", \"leaflet-bar-part leaflet-bar-part-single\", container);\n      link.title = options.strings.title;\n      link.href = \"#\";\n      link.setAttribute(\"role\", \"button\");\n      const icon = DomUtil.create(options.iconElementTag, options.icon, link);\n\n      if (options.strings.text !== undefined) {\n        const text = DomUtil.create(options.textElementTag, \"leaflet-locate-text\", link);\n        text.textContent = options.strings.text;\n        link.classList.add(\"leaflet-locate-text-active\");\n        link.parentNode.style.display = \"flex\";\n        if (options.icon.length > 0) {\n          icon.classList.add(\"leaflet-locate-icon\");\n        }\n      }\n\n      return { link, icon };\n    },\n    /** This event is called in case of any location error that is not a time out error. */\n    onLocationError(err, control) {\n      alert(err.message);\n    },\n    /**\n     * This event is called when the user's location is outside the bounds set on the map.\n     * The event is called repeatedly when the location changes.\n     */\n    onLocationOutsideMapBounds(control) {\n      control.stop();\n      alert(control.options.strings.outsideMapBoundsMsg);\n    },\n    /** Display a pop-up when the user click on the inner marker. */\n    showPopup: true,\n    strings: {\n      title: \"Show me where I am\",\n      metersUnit: \"meters\",\n      feetUnit: \"feet\",\n      popup: \"You are within {distance} {unit} from this point\",\n      outsideMapBoundsMsg: \"You seem located outside the boundaries of the map\"\n    },\n    /** The default options passed to leaflets locate method. */\n    locateOptions: {\n      maxZoom: Infinity,\n      watch: true, // if you overwrite this, visualization cannot be updated\n      setView: false // have to set this to false because we have to\n      // do setView manually\n    }\n  },\n\n  initialize(options) {\n    // set default options if nothing is set (merge one step deep)\n    for (const i in options) {\n      if (typeof this.options[i] === \"object\") {\n        extend(this.options[i], options[i]);\n      } else {\n        this.options[i] = options[i];\n      }\n    }\n\n    // extend the follow marker style and circle from the normal style\n    this.options.followMarkerStyle = extend({}, this.options.markerStyle, this.options.followMarkerStyle);\n    this.options.followCircleStyle = extend({}, this.options.circleStyle, this.options.followCircleStyle);\n    this.options.followCompassStyle = extend({}, this.options.compassStyle, this.options.followCompassStyle);\n  },\n\n  /**\n   * Add control to map. Returns the container for the control.\n   */\n  onAdd(map) {\n    const container = DomUtil.create(\"div\", \"leaflet-control-locate leaflet-bar leaflet-control\");\n    this._container = container;\n    this._map = map;\n    this._layer = this.options.layer || new LayerGroup();\n    this._layer.addTo(map);\n    this._event = undefined;\n    this._compassHeading = null;\n    this._prevBounds = null;\n\n    const linkAndIcon = this.options.createButtonCallback(container, this.options);\n    this._link = linkAndIcon.link;\n    this._icon = linkAndIcon.icon;\n\n    DomEvent.on(\n      this._link,\n      \"click\",\n      function (ev) {\n        DomEvent.stopPropagation(ev);\n        DomEvent.preventDefault(ev);\n        this._onClick();\n      },\n      this\n    ).on(this._link, \"dblclick\", DomEvent.stopPropagation);\n\n    this._resetVariables();\n\n    this._map.on(\"unload\", this._unload, this);\n\n    return container;\n  },\n\n  /**\n   * This method is called when the user clicks on the control.\n   */\n  _onClick() {\n    this._justClicked = true;\n    const wasFollowing = this._isFollowing();\n    this._userPanned = false;\n    this._userZoomed = false;\n\n    if (this._active && !this._event) {\n      // click while requesting\n      this.stop();\n    } else if (this._active) {\n      const behaviors = this.options.clickBehavior;\n      let behavior = behaviors.outOfView;\n      if (this._map.getBounds().contains(this._event.latlng)) {\n        behavior = wasFollowing ? behaviors.inView : behaviors.inViewNotFollowing;\n      }\n\n      // Allow inheriting from another behavior\n      if (behaviors[behavior]) {\n        behavior = behaviors[behavior];\n      }\n\n      switch (behavior) {\n        case \"setView\":\n          this.setView();\n          break;\n        case \"stop\":\n          this.stop();\n          if (this.options.returnToPrevBounds) {\n            const f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n            f.bind(this._map)(this._prevBounds);\n          }\n          break;\n      }\n    } else {\n      if (this.options.returnToPrevBounds) {\n        this._prevBounds = this._map.getBounds();\n      }\n      this.start();\n    }\n\n    this._updateContainerStyle();\n  },\n\n  /**\n   * Starts the plugin:\n   * - activates the engine\n   * - draws the marker (if coordinates available)\n   */\n  start() {\n    this._activate();\n\n    if (this._event) {\n      this._drawMarker(this._map);\n\n      // if we already have a location but the user clicked on the control\n      if (this.options.setView) {\n        this.setView();\n      }\n    }\n    this._updateContainerStyle();\n  },\n\n  /**\n   * Stops the plugin:\n   * - deactivates the engine\n   * - reinitializes the button\n   * - removes the marker\n   */\n  stop() {\n    this._deactivate();\n\n    this._cleanClasses();\n    this._resetVariables();\n\n    this._removeMarker();\n  },\n\n  /**\n   * Keep the control active but stop following the location\n   */\n  stopFollowing() {\n    this._userPanned = true;\n    this._updateContainerStyle();\n    this._drawMarker();\n  },\n\n  /**\n   * This method launches the location engine.\n   * It is called before the marker is updated,\n   * event if it does not mean that the event will be ready.\n   *\n   * Override it if you want to add more functionalities.\n   * It should set the this._active to true and do nothing if\n   * this._active is true.\n   */\n  _activate() {\n    if (this._active || !this._map) {\n      return;\n    }\n\n    this._map.locate(this.options.locateOptions);\n    this._map.fire(\"locateactivate\", this);\n    this._active = true;\n\n    // bind event listeners\n    this._map.on(\"locationfound\", this._onLocationFound, this);\n    this._map.on(\"locationerror\", this._onLocationError, this);\n    this._map.on(\"dragstart\", this._onDrag, this);\n    this._map.on(\"zoomstart\", this._onZoom, this);\n    this._map.on(\"zoomend\", this._onZoomEnd, this);\n    if (this.options.showCompass) {\n      const oriAbs = \"ondeviceorientationabsolute\" in window;\n      if (oriAbs || \"ondeviceorientation\" in window) {\n        const _this = this;\n        const deviceorientation = function () {\n          DomEvent.on(window, oriAbs ? \"deviceorientationabsolute\" : \"deviceorientation\", _this._onDeviceOrientation, _this);\n        };\n        if (DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === \"function\") {\n          DeviceOrientationEvent.requestPermission().then(function (permissionState) {\n            if (permissionState === \"granted\") {\n              deviceorientation();\n            }\n          });\n        } else {\n          deviceorientation();\n        }\n      }\n    }\n  },\n\n  /**\n   * Called to stop the location engine.\n   *\n   * Override it to shutdown any functionalities you added on start.\n   */\n  _deactivate() {\n    if (!this._active || !this._map) {\n      return;\n    }\n\n    this._map.stopLocate();\n    this._map.fire(\"locatedeactivate\", this);\n    this._active = false;\n\n    if (!this.options.cacheLocation) {\n      this._event = undefined;\n    }\n\n    // unbind event listeners\n    this._map.off(\"locationfound\", this._onLocationFound, this);\n    this._map.off(\"locationerror\", this._onLocationError, this);\n    this._map.off(\"dragstart\", this._onDrag, this);\n    this._map.off(\"zoomstart\", this._onZoom, this);\n    this._map.off(\"zoomend\", this._onZoomEnd, this);\n    if (this.options.showCompass) {\n      this._compassHeading = null;\n      if (\"ondeviceorientationabsolute\" in window) {\n        DomEvent.off(window, \"deviceorientationabsolute\", this._onDeviceOrientation, this);\n      } else if (\"ondeviceorientation\" in window) {\n        DomEvent.off(window, \"deviceorientation\", this._onDeviceOrientation, this);\n      }\n    }\n  },\n\n  /**\n   * Zoom (unless we should keep the zoom level) and an to the current view.\n   */\n  setView() {\n    this._drawMarker();\n    if (this._isOutsideMapBounds()) {\n      this._event = undefined; // clear the current location so we can get back into the bounds\n      this.options.onLocationOutsideMapBounds(this);\n    } else {\n      if (this._justClicked && this.options.initialZoomLevel !== false) {\n        let f = this.options.flyTo ? this._map.flyTo : this._map.setView;\n        f.bind(this._map)([this._event.latitude, this._event.longitude], this.options.initialZoomLevel);\n      } else if (this.options.keepCurrentZoomLevel) {\n        let f = this.options.flyTo ? this._map.flyTo : this._map.panTo;\n        f.bind(this._map)([this._event.latitude, this._event.longitude]);\n      } else {\n        let f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;\n        // Ignore zoom events while setting the viewport as these would stop following\n        this._ignoreEvent = true;\n        f.bind(this._map)(this.options.getLocationBounds(this._event), {\n          padding: this.options.circlePadding,\n          maxZoom: this.options.initialZoomLevel || this.options.locateOptions.maxZoom\n        });\n        LeafletUtil.requestAnimFrame(function () {\n          // Wait until after the next animFrame because the flyTo can be async\n          this._ignoreEvent = false;\n        }, this);\n      }\n    }\n  },\n\n  /**\n   *\n   */\n  _drawCompass() {\n    if (!this._event) {\n      return;\n    }\n\n    const latlng = this._event.latlng;\n\n    if (this.options.showCompass && latlng && this._compassHeading !== null) {\n      const cStyle = this._isFollowing() ? this.options.followCompassStyle : this.options.compassStyle;\n      if (!this._compass) {\n        this._compass = new this.options.compassClass(latlng, this._compassHeading, cStyle).addTo(this._layer);\n      } else {\n        this._compass.setLatLng(latlng);\n        this._compass.setHeading(this._compassHeading);\n        // If the compassClass can be updated with setStyle, update it.\n        if (this._compass.setStyle) {\n          this._compass.setStyle(cStyle);\n        }\n      }\n      //\n    }\n    if (this._compass && (!this.options.showCompass || this._compassHeading === null)) {\n      this._compass.removeFrom(this._layer);\n      this._compass = null;\n    }\n  },\n\n  /**\n   * Draw the marker and accuracy circle on the map.\n   *\n   * Uses the event retrieved from onLocationFound from the map.\n   */\n  _drawMarker() {\n    if (this._event.accuracy === undefined) {\n      this._event.accuracy = 0;\n    }\n\n    const radius = this._event.accuracy;\n    const latlng = this._event.latlng;\n\n    // circle with the radius of the location's accuracy\n    if (this.options.drawCircle) {\n      const style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;\n\n      if (!this._circle) {\n        this._circle = circle(latlng, radius, style).addTo(this._layer);\n      } else {\n        this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);\n      }\n    }\n\n    let distance;\n    let unit;\n    if (this.options.metric) {\n      distance = radius.toFixed(0);\n      unit = this.options.strings.metersUnit;\n    } else {\n      distance = (radius * 3.2808399).toFixed(0);\n      unit = this.options.strings.feetUnit;\n    }\n\n    // small inner marker\n    if (this.options.drawMarker) {\n      const mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;\n      if (!this._marker) {\n        this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);\n      } else {\n        this._marker.setLatLng(latlng);\n        // If the markerClass can be updated with setStyle, update it.\n        if (this._marker.setStyle) {\n          this._marker.setStyle(mStyle);\n        }\n      }\n    }\n\n    this._drawCompass();\n\n    const t = this.options.strings.popup;\n    function getPopupText() {\n      if (typeof t === \"string\") {\n        return LeafletUtil.template(t, { distance, unit });\n      } else if (typeof t === \"function\") {\n        return t({ distance, unit });\n      } else {\n        return t;\n      }\n    }\n    if (this.options.showPopup && t && this._marker) {\n      this._marker.bindPopup(getPopupText())._popup.setLatLng(latlng);\n    }\n    if (this.options.showPopup && t && this._compass) {\n      this._compass.bindPopup(getPopupText())._popup.setLatLng(latlng);\n    }\n  },\n\n  /**\n   * Remove the marker from map.\n   */\n  _removeMarker() {\n    this._layer.clearLayers();\n    this._marker = undefined;\n    this._circle = undefined;\n  },\n\n  /**\n   * Unload the plugin and all event listeners.\n   * Kind of the opposite of onAdd.\n   */\n  _unload() {\n    this.stop();\n    // May become undefined during HMR\n    if (this._map) {\n      this._map.off(\"unload\", this._unload, this);\n    }\n  },\n\n  /**\n   * Sets the compass heading\n   */\n  _setCompassHeading(angle) {\n    if (!isNaN(parseFloat(angle)) && isFinite(angle)) {\n      angle = Math.round(angle);\n\n      this._compassHeading = angle;\n      LeafletUtil.requestAnimFrame(this._drawCompass, this);\n    } else {\n      this._compassHeading = null;\n    }\n  },\n\n  /**\n   * If the compass fails calibration just fail safely and remove the compass\n   */\n  _onCompassNeedsCalibration() {\n    this._setCompassHeading();\n  },\n\n  /**\n   * Process and normalise compass events\n   */\n  _onDeviceOrientation(e) {\n    if (!this._active) {\n      return;\n    }\n\n    if (e.webkitCompassHeading) {\n      // iOS\n      this._setCompassHeading(e.webkitCompassHeading);\n    } else if (e.absolute && e.alpha) {\n      // Android\n      this._setCompassHeading(360 - e.alpha);\n    }\n  },\n\n  /**\n   * Calls deactivate and dispatches an error.\n   */\n  _onLocationError(err) {\n    // ignore time out error if the location is watched\n    if (err.code == 3 && this.options.locateOptions.watch) {\n      return;\n    }\n\n    this.stop();\n    this.options.onLocationError(err, this);\n  },\n\n  /**\n   * Stores the received event and updates the marker.\n   */\n  _onLocationFound(e) {\n    // no need to do anything if the location has not changed\n    if (this._event && this._event.latlng.lat === e.latlng.lat && this._event.latlng.lng === e.latlng.lng && this._event.accuracy === e.accuracy) {\n      return;\n    }\n\n    if (!this._active) {\n      // we may have a stray event\n      return;\n    }\n\n    this._event = e;\n\n    this._drawMarker();\n    this._updateContainerStyle();\n\n    switch (this.options.setView) {\n      case \"once\":\n        if (this._justClicked) {\n          this.setView();\n        }\n        break;\n      case \"untilPan\":\n        if (!this._userPanned) {\n          this.setView();\n        }\n        break;\n      case \"untilPanOrZoom\":\n        if (!this._userPanned && !this._userZoomed) {\n          this.setView();\n        }\n        break;\n      case \"always\":\n        this.setView();\n        break;\n      case false:\n        // don't set the view\n        break;\n    }\n\n    this._justClicked = false;\n  },\n\n  /**\n   * When the user drags. Need a separate event so we can bind and unbind event listeners.\n   */\n  _onDrag() {\n    // only react to drags once we have a location\n    if (this._event && !this._ignoreEvent) {\n      this._userPanned = true;\n      this._updateContainerStyle();\n      this._drawMarker();\n    }\n  },\n\n  /**\n   * When the user zooms. Need a separate event so we can bind and unbind event listeners.\n   */\n  _onZoom() {\n    // only react to drags once we have a location\n    if (this._event && !this._ignoreEvent) {\n      this._userZoomed = true;\n      this._updateContainerStyle();\n      this._drawMarker();\n    }\n  },\n\n  /**\n   * After a zoom ends update the compass and handle sideways zooms\n   */\n  _onZoomEnd() {\n    if (this._event) {\n      this._drawCompass();\n    }\n\n    if (this._event && !this._ignoreEvent) {\n      // If we have zoomed in and out and ended up sideways treat it as a pan\n      if (this._marker && !this._map.getBounds().pad(-0.3).contains(this._marker.getLatLng())) {\n        this._userPanned = true;\n        this._updateContainerStyle();\n        this._drawMarker();\n      }\n    }\n  },\n\n  /**\n   * Compute whether the map is following the user location with pan and zoom.\n   */\n  _isFollowing() {\n    if (!this._active) {\n      return false;\n    }\n\n    if (this.options.setView === \"always\") {\n      return true;\n    } else if (this.options.setView === \"untilPan\") {\n      return !this._userPanned;\n    } else if (this.options.setView === \"untilPanOrZoom\") {\n      return !this._userPanned && !this._userZoomed;\n    }\n  },\n\n  /**\n   * Check if location is in map bounds\n   */\n  _isOutsideMapBounds() {\n    if (this._event === undefined) {\n      return false;\n    }\n    return this._map.options.maxBounds && !this._map.options.maxBounds.contains(this._event.latlng);\n  },\n\n  /**\n   * Toggles button class between following and active.\n   */\n  _updateContainerStyle() {\n    if (!this._container) {\n      return;\n    }\n\n    if (this._active && !this._event) {\n      // active but don't have a location yet\n      this._setClasses(\"requesting\");\n    } else if (this._isFollowing()) {\n      this._setClasses(\"following\");\n    } else if (this._active) {\n      this._setClasses(\"active\");\n    } else {\n      this._cleanClasses();\n    }\n  },\n\n  /**\n   * Sets the CSS classes for the state.\n   */\n  _setClasses(state) {\n    if (state == \"requesting\") {\n      removeClasses(this._container, \"active following\");\n      addClasses(this._container, \"requesting\");\n\n      removeClasses(this._icon, this.options.icon);\n      addClasses(this._icon, this.options.iconLoading);\n    } else if (state == \"active\") {\n      removeClasses(this._container, \"requesting following\");\n      addClasses(this._container, \"active\");\n\n      removeClasses(this._icon, this.options.iconLoading);\n      addClasses(this._icon, this.options.icon);\n    } else if (state == \"following\") {\n      removeClasses(this._container, \"requesting\");\n      addClasses(this._container, \"active following\");\n\n      removeClasses(this._icon, this.options.iconLoading);\n      addClasses(this._icon, this.options.icon);\n    }\n  },\n\n  /**\n   * Removes all classes from button.\n   */\n  _cleanClasses() {\n    DomUtil.removeClass(this._container, \"requesting\");\n    DomUtil.removeClass(this._container, \"active\");\n    DomUtil.removeClass(this._container, \"following\");\n\n    removeClasses(this._icon, this.options.iconLoading);\n    addClasses(this._icon, this.options.icon);\n  },\n\n  /**\n   * Reinitializes state variables.\n   */\n  _resetVariables() {\n    // whether locate is active or not\n    this._active = false;\n\n    // true if the control was clicked for the first time\n    // we need this so we can pan and zoom once we have the location\n    this._justClicked = false;\n\n    // true if the user has panned the map after clicking the control\n    this._userPanned = false;\n\n    // true if the user has zoomed the map after clicking the control\n    this._userZoomed = false;\n  }\n});\n\nfunction locate(options) {\n  return new LocateControl(options);\n}\n\nexport { LocationMarker, CompassMarker, LocateControl, locate };\n"],"names":["addClasses","el","names","split","forEach","className","classList","add","removeClasses","remove","LocationMarker","Marker","extend","initialize","latlng","options","setOptions","this","_latlng","createIcon","opt","style","color","weight","fillColor","fillOpacity","opacity","filter","k","v","undefined","map","join","icon","_getIconSVG","_locationIcon","divIcon","html","svg","iconSize","w","h","setIcon","r","radius","s","s2","setStyle","CompassMarker","heading","_heading","setHeading","depth","_arrowPoints","width","Math","PI","ux","cos","uy","sin","vx","vy","Cx","Cy","LocateControl","Control","position","layer","setView","keepCurrentZoomLevel","initialZoomLevel","getLocationBounds","locationEvent","bounds","flyTo","clickBehavior","inView","outOfView","inViewNotFollowing","returnToPrevBounds","cacheLocation","drawCircle","drawMarker","showCompass","markerClass","compassClass","circleStyle","markerStyle","compassStyle","followCircleStyle","followMarkerStyle","followCompassStyle","iconLoading","iconElementTag","textElementTag","circlePadding","metric","createButtonCallback","container","link","DomUtil","create","title","strings","href","setAttribute","text","textContent","parentNode","display","length","onLocationError","err","control","alert","message","onLocationOutsideMapBounds","stop","outsideMapBoundsMsg","showPopup","metersUnit","feetUnit","popup","locateOptions","maxZoom","Infinity","watch","i","onAdd","_container","_map","_layer","LayerGroup","addTo","_event","_compassHeading","_prevBounds","linkAndIcon","_link","_icon","DomEvent","on","ev","stopPropagation","preventDefault","_onClick","_resetVariables","_unload","_justClicked","wasFollowing","_isFollowing","_userPanned","_userZoomed","_active","behaviors","behavior","getBounds","contains","flyToBounds","fitBounds","bind","f","start","_updateContainerStyle","_activate","_drawMarker","_deactivate","_cleanClasses","_removeMarker","stopFollowing","locate","fire","_onLocationFound","_onLocationError","_onDrag","_onZoom","_onZoomEnd","oriAbs","window","_this","deviceorientation","_onDeviceOrientation","DeviceOrientationEvent","requestPermission","then","permissionState","stopLocate","off","_isOutsideMapBounds","latitude","longitude","panTo","_ignoreEvent","padding","LeafletUtil","requestAnimFrame","_drawCompass","cStyle","_compass","setLatLng","removeFrom","accuracy","_circle","setRadius","circle","distance","unit","toFixed","mStyle","_marker","t","getPopupText","template","bindPopup","_popup","clearLayers","_setCompassHeading","angle","isNaN","parseFloat","isFinite","round","_onCompassNeedsCalibration","e","webkitCompassHeading","absolute","alpha","code","lat","lng","pad","getLatLng","maxBounds","_setClasses","state","removeClass"],"mappings":"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"}
